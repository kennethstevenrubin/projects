////////////////////////////////////////
// model

function Model() {

    this.id = 1;                            // Identification number of object.
    this.culled = false;                    // Indicates the object is not drawn this frame.
    this.radius = 0;                        // The average radius of object.
    this.num_verticies = 0;                 // Total number of vertices in object.

    this.world_pos = new Vector(0, 0, 0);   // Position of object in world coordinates.
    this.rotation = new Vector(0, 0, 0);    // Rotation about each axis.
    this.scale = 1;                         // Scaling.

    this.polys = [];                        // The polygons that make up the object.
    this.verticies_local = [];              // Local verticies.
    this.verticies_scaled = [];             // Scaled verticies.
    this.verticies_rotated = [];            // Rotated verticies.
    this.verticies_world = [];              // World verticies.
    this.verticies_camera = [];             // Camera verticies.

    // Update the state of the object for this frame.
    this.update = function (dTotal,
        dEllapsed,
        renderer) {

        // Here just always try to cull the object immediately.
        // It does its own internal translations and so is isolated.
        this.Cull_Object(renderer.global_view.data,
            renderer.inverseAspectRatio,
            renderer.halfScreenWidth,
            renderer.halfScreenHeight,
            renderer.viewingDistance);
        if (this.culled === true) {

            return;

        }

        // Translate the object into the frame.
        this.Scale_Object(this.scale);
        this.Rotate_Object(this.rotation.x,
            this.rotation.y,
            this.rotation.z);
        this.Rotated_To_World_Object();
        this.World_To_Camera_Object(renderer.global_view.data);

        // Remove backfaces.
        this.Remove_Backfaces_And_Shade(renderer.viewPoint,
            renderer.lightSource,
            renderer.ambientLight);

        // Add polys to engine collection.
        this.Insert_Into_Poly_List(renderer.worldPolys);

    }

    // Method calculates all polygon normals.
    this.computePolygonNormals = function () {

        for (var i = 0; i < this.polys.length; i++) {

            var poly = this.polys[i];

            poly.computeNormal(this.verticies_local);

        }

    }

    // Method positions an object in the world.
    this.setWorldPosition = function (x,
        y,
        z) {

        this.world_pos.x = x;
        this.world_pos.y = y;
        this.world_pos.z = z;

    };

    // Method positions an object in the world.
    this.setRotation = function (x,
        y,
        z) {

        this.rotation.x = x;
        this.rotation.y = y;
        this.rotation.z = z;

    };

    // Method positions an object in the world.
    this.setScale = function (factor) {

        this.scale = factor;

    };

    // Method converts an object's local coordinates to world coordinates
    // translating each point in the object by the objects current position.
    this.Rotated_To_World_Object = function () {

        this.verticies_world = [];

        // Move object from local position to world position.
        for (var index = 0; index < this.num_verticies; index++) {

            this.verticies_world.push(new Vector(
                this.verticies_rotated[index].x +
                    this.world_pos.x,
                this.verticies_rotated[index].y +
                    this.world_pos.y,
                this.verticies_rotated[index].z +
                    this.world_pos.z));

        } // End for index.

        // Reset visibility flags for all polys.
        for (index = 0; index < this.polys.length; index++) {

            this.polys[index].visible = true;

        } // End for.
    };

    // Method converts an objects world coordinates to camera coordinates by 
    // multiplying each point of the object by the inverse viewing transformation
    // matrix which is generated by concatenating the inverse of the view 
    // position and the view angles the result of which is in global_view.
    this.World_To_Camera_Object = function (camera) {

        // Iterate thru all verticies of object and transform them into camera coordinates.
        this.verticies_camera = [];

        for (var index = 0; index < this.num_verticies; index++) {

            // Multiply the point by the viewing transformation matrix.
            var vectorWorld = this.verticies_world[index];

            // X component.
            this.verticies_camera.push(new Vector(
                vectorWorld.x * camera[0][0] +
                vectorWorld.y * camera[1][0] +
                vectorWorld.z * camera[2][0] +
                camera[3][0],

                vectorWorld.x * camera[0][1] +
                vectorWorld.y * camera[1][1] +
                vectorWorld.z * camera[2][1] +
                camera[3][1],

                vectorWorld.x * camera[0][2] +
                vectorWorld.y * camera[1][2] +
                vectorWorld.z * camera[2][2] +
                camera[3][2]));

        } // end for index
    };

    // Method rotates an object relative to it's own local 
    // coordinate system and allows simultaneous rotations.
    this.Rotate_Object = function (angle_x,
        angle_y,
        angle_z) {

        var product = 0;                    // Used to determine which matrices need multiplying.

        var rotate_x = null;    // The x,y and z rotation matrices.
        var rotate_y = null;
        var rotate_z = null;
        var rotate = new Matrix();      // The final rotation matrix.

        // Test if we need to rotate at all.
        if (angle_x === 0 &&
            angle_y === 0 &&
            angle_z === 0) {

            return;

        }

        // Create X rotation matrix.
        if (angle_x !== 0) {

            // X matrix.
            rotate_x = new Matrix();    // The x,y and z rotation matrices.
            rotate_x.data[1][1] = (Math.cos(angle_x));
            rotate_x.data[1][2] = (Math.sin(angle_x));
            rotate_x.data[2][1] = (-Math.sin(angle_x));
            rotate_x.data[2][2] = (Math.cos(angle_x));

            // If bit 2 of product is 1 then there is an x rotation
            product += 4;

        } // End if any X rotation.

        // Create Y rotation matrix.
        if (angle_y !== 0) {

            // Y matrix.
            rotate_y = new Matrix();
            rotate_y.data[0][0] = (Math.cos(angle_y));
            rotate_y.data[0][2] = (-Math.sin(angle_y));
            rotate_y.data[2][0] = (Math.sin(angle_y));
            rotate_y.data[2][2] = (Math.cos(angle_y));

            // If bit 1 of product is 1 then there is an y rotation
            product += 2;

        } // End if any Y rotation.

        // Create Z rotation matrix.
        if (angle_z !== 0) {

            // Z matrix.
            rotate_z = new Matrix();
            rotate_z.data[0][0] = (Math.cos(angle_z));
            rotate_z.data[0][1] = (Math.sin(angle_z));
            rotate_z.data[1][0] = (-Math.sin(angle_z));
            rotate_z.data[1][1] = (Math.cos(angle_z));

            // If bit 0 of product is 1 then there is an z rotation
            product += 1;

        } // End if any Z rotation.

        // Compute final rotation matrix, determine the proper product of matrices
        // use a switch statement along with a bit pattern to determine which
        // matrices need multiplying, this is worth the time it would take
        // to concatenate matrices together that don't have any effect.

        // Compute proper final rotation matrix.
        switch (product) {

            // Do nothing there isn't any rotation.      
            case 0:
                {

                    // This shouldn't happen.

                } break;

            // Final matrix = z.      
            case 1:
                {

                    rotate_z.Mat_Copy(rotate);

                } break;

            // Final matrix = y.      
            case 2:
                {

                    rotate_y.Mat_Copy(rotate);

                } break;

            // Final matrix = y*z.      
            case 3:
                {

                    rotate_y.Mat_Mul(rotate_z,
                        rotate);

                } break;

            // Final matrix = x.      
            case 4:
                {

                    rotate_x.Mat_Copy(rotate);

                } break;

            // final matrix = x*z.      
            case 5:
                {

                    rotate_x.Mat_Mul(rotate_z,
                        rotate);

                } break;

            // final matrix = x*y.      
            case 6:
                {

                    rotate_x.Mat_Mul(rotate_y,
                        rotate);

                } break;

            // final matrix = x*y*z.      
            case 7:
                {

                    var temp = new Matrix();
                    rotate_x.Mat_Mul(rotate_y,
                        temp);
                    temp.Mat_Mul(rotate_z,
                        rotate);

                } break;

            default: break;

        } // End switch.

        this.verticies_rotated = [];

        var rotateData = rotate.data;

        // Now multiply each point in object by transformation matrix.
        for (var index = 0; index < this.num_verticies; index++) {

            var scaled = this.verticies_scaled[index];
            this.verticies_rotated.push(new Vector(
                scaled.x * rotateData[0][0] +
                scaled.y * rotateData[1][0] +
                scaled.z * rotateData[2][0],

                scaled.x * rotateData[0][1] +
                scaled.y * rotateData[1][1] +
                scaled.z * rotateData[2][1],

                scaled.x * rotateData[0][2] +
                scaled.y * rotateData[1][2] +
                scaled.z * rotateData[2][2]));

        }

        for (var index = 0; index < this.polys.length; index++) {

            var poly = this.polys[index].normal;
            this.polys[index].normalRotated = new Vector(
                poly.x * rotateData[0][0] +
                poly.y * rotateData[1][0] +
                poly.z * rotateData[2][0],

                poly.x * rotateData[0][1] +
                poly.y * rotateData[1][1] +
                poly.z * rotateData[2][1],

                poly.x * rotateData[0][2] +
                poly.y * rotateData[1][2] +
                poly.z * rotateData[2][2]);

        }

    };

    // Method scales an object relative to it's own 
    // local coordinate system equally in x, y and z.
    this.Scale_Object = function (scale_factor) {

        // Drop out if not scaling.
        if (scale_factor === 1) {

            this.verticies_scaled = this.verticies_local;
            return;

        }

        this.verticies_scaled = [];

        // Multiply each vertex in the object definition by the scaling factor.
        for (var curr_vertex = 0; curr_vertex < this.num_verticies; curr_vertex++) {

            this.verticies_scaled.push(new Vector(this.verticies_local[curr_vertex].x * scale_factor,
                this.verticies_local[curr_vertex].y * scale_factor,
                this.verticies_local[curr_vertex].z * scale_factor));

        } // End for curr_vertex.

        // Finally scale the radius up.
        this.radius *= scale_factor;

    };

    // Method computes maximum radius of object, maybe a better 
    // method would use average radius? Note that this functiopn 
    // shouldn't be used during runtime but when an object is created.
    this.Compute_Object_Radius = function () {

        // Reset object radius.
        this.radius = 0;

        // Test each vertex.
        for (var index = 0; index < this.num_verticies; index++) {

            var new_radius = this.verticies_local[index].Vector_Mag();

            // Is this radius bigger than last?
            if (new_radius > this.radius) {

                this.radius = new_radius;

            } // End if bigger.
        } // End for index.
    };

    // Method removes all the backfaces of an object by setting the removed
    // flag. This function assumes that the object has been transformed into
    // camera coordinates. Also, the function computes the flat shading of object.
    this.Remove_Backfaces_And_Shade = function (viewPoint,
        lightSource,
        ambientLight) {

        // For each polygon in the object determine if it 
        // is pointing away from the viewpoint and direction.
        for (var curr_poly = 0; curr_poly < this.polys.length; curr_poly++) {

            var poly = this.polys[curr_poly];

            // Extract normal from polygon.
            var normal = poly.normalRotated;

            // Compute the line of sight vector, since all coordinates are 
            // world all object verticies are already relative to (0,0,0).
            var sight = new Vector();
            sight.x = viewPoint.x - this.verticies_world[poly.index0].x;
            sight.y = viewPoint.y - this.verticies_world[poly.index0].y;
            sight.z = viewPoint.z - this.verticies_world[poly.index0].z;

            // Compute the dot product between line of sight vector and normal to surface.
            var dp = normal.Dot_Product(sight);

            // Set the visible flagged appropriately.
            if (dp > 0) {

                // Set visibility.
                poly.visible = true;

                // Compute the dot product between the light 
                // source vector and normal vector to surface.
                dp = normal.Dot_Product(lightSource);

                // Test if intensity has under- or overflown.
                if (dp < ambientLight) {

                    dp = ambientLight;

                } else if (dp > 1) {

                    dp = 1;

                }

                // Intensity now varies from 0-1, 0 being black or grazing and 1
                // totally illuminated. use the value to index into color table.
                poly.shade = poly.getColor(dp);

            } else {

                // Set invisible flag.
                poly.visible = false;

            } // End if face is visible.
        } // End for curr_poly.
    };

    // Method is used to generate the final polygon list that 
    // will be rendered. Object by object the list is built up.
    this.Insert_Into_Poly_List = function (worldPolys) {

        // Insert all visible polygons into polygon list.
        for (var curr_poly = 0; curr_poly < this.polys.length; curr_poly++) {

            // Get the poly.
            var polyCurrent = this.polys[curr_poly];

            // Test if this poly is visible, if so add it to poly list.
            if (polyCurrent.visible === true) {

                polyCurrent.vector0 = this.verticies_camera[polyCurrent.index0];
                polyCurrent.vector1 = this.verticies_camera[polyCurrent.index1];
                polyCurrent.vector2 = this.verticies_camera[polyCurrent.index2];
                polyCurrent.averageZ = 0.333333 * (polyCurrent.vector0.z +
                    polyCurrent.vector1.z +
                    polyCurrent.vector2.z);

                // Add the poly.
                worldPolys.push(polyCurrent);

            } // End if poly visible.
        } // End for curr_poly.
    };

    // Method determines if an entire object is within the viewing volume
    // or not by testing if the bounding sphere of the object in question
    // is within the viewing volume.  In essence, this function "culls".
    this.Cull_Object = function (global_view,
        inverseAspectRatio,
        halfScreenWidth,
        halfScreenHeight,
        viewingDistance) {

        // First transform world position of object into camera coordinates.
        // Compute x component.
        var x_bsphere = this.world_pos.x * global_view[0][0] +
            this.world_pos.y * global_view[1][0] +
            this.world_pos.z * global_view[2][0] +
            global_view[3][0];

        // Compute y component.
        var y_bsphere = this.world_pos.x * global_view[0][1] +
            this.world_pos.y * global_view[1][1] +
            this.world_pos.z * global_view[2][1] +
            global_view[3][1];

        // Compute z component.
        var z_bsphere = this.world_pos.x * global_view[0][2] +
            this.world_pos.y * global_view[1][2] +
            this.world_pos.z * global_view[2][2] +
            global_view[3][2];

        // Extract radius of object.
        var radius = this.radius * 2;       // Little trick to avoid a "popping" back into an edge case.

        // Perform full x, y, z test.
        if (((z_bsphere - radius) > this.clipFarZ) ||
            ((z_bsphere + radius) < this.clipNearZ)) {

            this.culled = true;
            return;

        }

        // Test against x right and left planes, first compute viewing 
        // volume extents at position z position of bounding sphere.
        var x_compare = (halfScreenWidth * z_bsphere) / viewingDistance;

        if (((x_bsphere - radius) > x_compare) ||
            ((x_bsphere + radius) < -x_compare)) {

            this.culled = true;
            return;

        }

        // Finally test against y top and bottom planes.
        var y_compare = (inverseAspectRatio * halfScreenHeight * z_bsphere) / viewingDistance;

        if (((y_bsphere - radius) > y_compare) ||
            ((y_bsphere + radius) < -y_compare)) {

            this.culled = true;
            return;

        }

        // In viewing frustum.
        this.culled = false;
    };

    // Method initializes object for tetrahedron.
    this.initializeTetrahedron = function () {

        // Define vertexes for tetrahedron.
        this.verticies_local.push(new Vector(-1, 1, 0));
        this.verticies_local.push(new Vector(1, 1, 0));
        this.verticies_local.push(new Vector(0, -1, -1));
        this.verticies_local.push(new Vector(0, -1, 1));

        // Make sure this is set.
        this.num_verticies = this.verticies_local.length;

        // Add the polygons.  Specify colors.
        var dRed = 127 + Math.floor(128 * Math.random());
        var dGreen = 127 + Math.floor(128 * Math.random());
        var dBlue = 127 + Math.floor(128 * Math.random());

        var polygonNew = new Polygon();
        polygonNew.index0 = 1;
        polygonNew.index1 = 0;
        polygonNew.index2 = 2;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 2;
        polygonNew.index1 = 3;
        polygonNew.index2 = 1;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 3;
        polygonNew.index1 = 2;
        polygonNew.index2 = 0;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 0;
        polygonNew.index1 = 1;
        polygonNew.index2 = 3;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

    }

    // Method initializes object for cube.
    this.initializeCube = function () {

        // Define vertexes for cube.
        this.verticies_local.push(new Vector(-1, -1, -1));
        this.verticies_local.push(new Vector(1, -1, -1));
        this.verticies_local.push(new Vector(1, -1, 1));
        this.verticies_local.push(new Vector(-1, -1, 1));
        this.verticies_local.push(new Vector(-1, 1, -1));
        this.verticies_local.push(new Vector(1, 1, -1));
        this.verticies_local.push(new Vector(1, 1, 1));
        this.verticies_local.push(new Vector(-1, 1, 1));

        // Make sure this is set.
        this.num_verticies = this.verticies_local.length;

        // Add the polygons.  Specify colors.
        var dRed = 127 + Math.floor(128 * Math.random());
        var dGreen = 127 + Math.floor(128 * Math.random());
        var dBlue = 127 + Math.floor(128 * Math.random());

        // Front.
        var polygonNew = new Polygon();
        polygonNew.index0 = 0;
        polygonNew.index1 = 1;
        polygonNew.index2 = 5;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 0;
        polygonNew.index1 = 5;
        polygonNew.index2 = 4;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        // Right.
        polygonNew = new Polygon();
        polygonNew.index0 = 1;
        polygonNew.index1 = 2;
        polygonNew.index2 = 6;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 1;
        polygonNew.index1 = 6;
        polygonNew.index2 = 5;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        // Back.
        polygonNew = new Polygon();
        polygonNew.index0 = 2;
        polygonNew.index1 = 3;
        polygonNew.index2 = 7;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 2;
        polygonNew.index1 = 7;
        polygonNew.index2 = 6;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        // Left.
        polygonNew = new Polygon();
        polygonNew.index0 = 3;
        polygonNew.index1 = 0;
        polygonNew.index2 = 4;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 3;
        polygonNew.index1 = 4;
        polygonNew.index2 = 7;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        // Top.
        polygonNew = new Polygon();
        polygonNew.index0 = 4;
        polygonNew.index1 = 5;
        polygonNew.index2 = 6;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 4;
        polygonNew.index1 = 6;
        polygonNew.index2 = 7;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        // Bottom.
        polygonNew = new Polygon();
        polygonNew.index0 = 2;
        polygonNew.index1 = 1;
        polygonNew.index2 = 0;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);

        polygonNew = new Polygon();
        polygonNew.index0 = 2;
        polygonNew.index1 = 0;
        polygonNew.index2 = 3;
        polygonNew.red = dRed;
        polygonNew.green = dGreen;
        polygonNew.blue = dBlue;
        this.polys.push(polygonNew);
    };

        // Method initializes object for cube.
    this.initializeSphere = function (rings,
        segments) {

        // Add the polygons.  Specify colors.
        var dRed = 127 + Math.floor(128 * Math.random());
        var dGreen = 127 + Math.floor(128 * Math.random());
        var dBlue = 127 + Math.floor(128 * Math.random());

        // Define vertexes for cube.
        this.verticies_local.push(new Vector(0, 1, 0));

        var dThetaPerRing = Math.PI / (rings + 1);

        for (var iRing = 0; iRing < rings; iRing++) {

            var dThetaForThisRing = (-Math.PI / 2) + (iRing + 1) * dThetaPerRing;

            var dYForThisRing = -Math.sin(dThetaForThisRing);

            for (var iSegment = 0; iSegment < segments; iSegment++) {

                var dPhiForThisSegment = 2 * Math.PI * iSegment / segments;
                var dXForThisSegment = Math.sin(dPhiForThisSegment) * Math.cos(dThetaForThisRing);
                var dZForThisSegment = Math.cos(dPhiForThisSegment) * Math.cos(dThetaForThisRing);
                this.verticies_local.push(new Vector(dXForThisSegment, dYForThisRing, dZForThisSegment));

            }

            if (iRing === 0) {

                for (var iSegment = 0; iSegment < segments; iSegment++) {

                    var polygonNew = new Polygon();
                    polygonNew.index0 = 0;

                    if (iSegment + 1 < segments) {

                        polygonNew.index1 = iSegment + 1 + 1;

                    } else {

                        polygonNew.index1 = 0 + 1;

                    }

                    polygonNew.index2 = iSegment + 1;

                    polygonNew.red = dRed;
                    polygonNew.green = dGreen;
                    polygonNew.blue = dBlue;

                    this.polys.push(polygonNew);

                }

            } else if (iRing < rings) {

                var iPreviousStartingRingIndex = (iRing - 1) * segments + 1;
                var iThisStartingRingIndex = iRing * segments + 1;

                for (var iSegment = 0; iSegment < segments; iSegment++) {

                    var polygonNew = new Polygon();
                    polygonNew.index0 = iPreviousStartingRingIndex + iSegment;

                    if (iSegment + 1 < segments) {
                        polygonNew.index1 = iPreviousStartingRingIndex + 1 + iSegment;
                    } else {
                        polygonNew.index1 = iPreviousStartingRingIndex;
                    }
                    if (iSegment + 1 < segments) {
                        polygonNew.index2 = iThisStartingRingIndex + 1 + iSegment;
                    } else {
                        polygonNew.index2 = iThisStartingRingIndex;
                    }

                    polygonNew.red = dRed;
                    polygonNew.green = dGreen;
                    polygonNew.blue = dBlue;
                    this.polys.push(polygonNew);

                    polygonNew = new Polygon();
                    polygonNew.index0 = iPreviousStartingRingIndex + iSegment;

                    if (iSegment + 1 < segments) {
                        polygonNew.index1 = iThisStartingRingIndex + 1 + iSegment;
                    } else {
                        polygonNew.index1 = iThisStartingRingIndex;
                    }
                    polygonNew.index2 = iThisStartingRingIndex + iSegment;

                    polygonNew.red = dRed;
                    polygonNew.green = dGreen;
                    polygonNew.blue = dBlue;
                    this.polys.push(polygonNew);
                }
            }
        }

        // North pole.
        this.verticies_local.push(new Vector(0, -1, 0));

        var iCount = this.verticies_local.length;

        for (var iSegment = 0; iSegment < segments; iSegment++) {

            var polygonNew = new Polygon();
            polygonNew.index0 = iCount - 1;

            polygonNew.index1 = iCount - 1 - segments + iSegment;

            if (iSegment + 1 < segments) {

                polygonNew.index2 = iCount - segments + iSegment;

            } else {

                polygonNew.index2 = iCount - 1 - segments;

            }

            polygonNew.red = dRed;
            polygonNew.green = dGreen;
            polygonNew.blue = dBlue;
            this.polys.push(polygonNew);

        }

        // Make sure this is set.
        this.num_verticies = this.verticies_local.length;

        this.computePolygonNormals();
    };
}
